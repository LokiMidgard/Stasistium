<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>

<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".tt.cs" #>
<#int maxSingleParameter = 4;
int maxListParameter =4;

#>
using Stasistium.Documents;
using System;
using Stasistium.Core;
using Stasistium;
using Stasistium.Stages;
using System.Collections.Immutable;
using System.Diagnostics.CodeAnalysis;
using System.Linq;
using System.Threading.Tasks;

namespace Stasistium.Stages.GeneratedHelper
{ 
<#
for(int single = 0; single<=maxSingleParameter;single++)
for(int list = 0; list<=maxListParameter;list++){

#>


    //////////////// SINGLE SIMPLE //////////////// 
<#{#>

<#
    var cacheType = "CacheId<string";
        for (int j = 0; j < single; j++)
        {
            cacheType+=", TPreviousSingleCache"+ j ;
        }
        for (int j = 0; j < list; j++)
        {
            cacheType+=", TPreviousListCache"+ j ;
        }
        cacheType+=">";

             
#>
namespace Single.Simple {
     public abstract class OutputSingleInputSingleSimple<#= single #>List<#= list #>StageBase<
    <#for(int j = 0; j< single; j++){#>
 TInputSingle<#= j #>, TPreviousSingleCache<#= j #>,
    <#}#>
        <#for(int j = 0; j< list; j++){#>
 TInputList<#= j #>, TPreviousItemCache<#= j #>, TPreviousListCache<#= j #>,
    <#}#>
 TResult
 > : StageBase<TResult, <#=cacheType#>>
        

            <#for(int j = 0; j< single; j++){#>
 where TPreviousSingleCache<#= j #> : class
    <#}#>
        <#for(int j = 0; j< list; j++){#>
 where TPreviousListCache<#= j #> : class
 where TPreviousItemCache<#= j #> : class

    <#}#>

    {
    <#for(int j = 0; j< single; j++){#>
        private readonly StageBase<TInputSingle<#= j #>, TPreviousSingleCache<#= j #>> inputSingle<#= j #>;
    <#}#>
    <#for(int j = 0; j< list; j++){#>
        private readonly MultiStageBase<TInputList<#= j #>, TPreviousItemCache<#= j #>, TPreviousListCache<#= j #>> inputList<#= j #>;
    <#}#>
        private readonly bool updateOnRefresh;

        public OutputSingleInputSingleSimple<#= single #>List<#= list #>StageBase(
    <#for(int j = 0; j< single; j++){#>
        StageBase<TInputSingle<#= j #>, TPreviousSingleCache<#= j #>> inputSingle<#= j #>,
    <#}#>
        <#for(int j = 0; j< list; j++){#>
        MultiStageBase<TInputList<#= j #>, TPreviousItemCache<#= j #>, TPreviousListCache<#= j #>> inputList<#= j #>,
    <#}#>
        IGeneratorContext context, string? name, bool updateOnRefresh = false) : base(context, name)
        {
    <#for(int j = 0; j< single; j++){#>
            this.inputSingle<#= j #> = inputSingle<#= j #>;
    <#}#>
    <#for(int j = 0; j< list; j++){#>
            this.inputList<#= j #> = inputList<#= j #>;
    <#}#>
            this.updateOnRefresh = updateOnRefresh;
        } 
        
        protected abstract Task<IDocument<TResult>> Work(<#for(int j = 0; j< single; j++)
        {
#>IDocument<TInputSingle<#= j #>> inputSingle<#= j#>, <#}#><#
        for(int j = 0; j< list; j++){
#>ImmutableList<IDocument<TInputList<#= j #>>> inputList<#= j#>, <#}
#>OptionToken options);

        protected sealed override async Task<StageResult<TResult, <#=cacheType#>>> DoInternal([AllowNull] <#=cacheType#>? cache, OptionToken options)
        {
            if (options is null)
                throw new ArgumentNullException(nameof(options));

<#
                if(single +list >1){
#>
            await Task.WhenAll(
<#for(int j = 0; j< single; j++){#>
                this.inputSingle<#= j #>.DoIt(cache?.PreviousCache<#= j #>, options),
<#}#>
<#for(int j = 0; j< list; j++){#>
                this.inputList<#= j #>.DoIt(cache?.PreviousCache<#= j + single #>, options),
<#}#>
                Task.CompletedTask
            ).ConfigureAwait(false);
                <#}#>
<#for(int j = 0; j< single; j++){#>
            var inputSingle<#= j #>Result = await this.inputSingle<#= j #>.DoIt(cache?.PreviousCache<#= j #>, options).ConfigureAwait(false);
<#}#>
<#for(int j = 0; j< list; j++){#>
            var inputList<#= j #>Result = await this.inputList<#= j #>.DoIt(cache?.PreviousCache<#= j + single #>, options).ConfigureAwait(false);
<#}#>


            var task = LazyTask.Create(async () =>
            {

        
<#
                if(single +list >1){
#>
            await Task.WhenAll(
<#for(int j = 0; j< single; j++){#>
                this.inputSingle<#= j #>.DoIt(cache?.PreviousCache<#= j #>, options),
<#}#>
<#for(int j = 0; j< list; j++){#>
                this.inputList<#= j #>.DoIt(cache?.PreviousCache<#= j + single #>, options),
<#}#>
                Task.CompletedTask
            ).ConfigureAwait(false);
                <#}#>
<#for(int j = 0; j< single; j++){#>
            var inputSingle<#= j #>Performed = await inputSingle<#= j #>Result.Perform;
<#}#>
<#for(int j = 0; j< list; j++){#>
            var inputList<#= j #>Performed = await inputList<#= j #>Result.Perform;

            var inputList<#= j #>PerformedListTask = Task.WhenAll(inputList<#= j #>Performed.Select(async x => (await x.Perform)));
<#}#>

<#if(list>1){#>
await Task.WhenAll(
<#for(int j = 0; j< list; j++){#>
<#if(j>0){#>, <#}#>
             inputList<#= j #>PerformedListTask
<#}#>
).ConfigureAwait(false);
<#}#>

<#for(int j = 0; j< list; j++){#>
            var inputList<#= j #>PerformedList = await inputList<#= j #>PerformedListTask.ConfigureAwait(false);
<#}#>


                var work = await this.Work(
                <#for(int j = 0; j< single; j++){#>
            inputSingle<#= j #>Performed,
<#}#>
<#for(int j = 0; j< list; j++){#>
            inputList<#= j #>PerformedList.ToImmutableList(),
<#}#>

                options).ConfigureAwait(false);
                
                return (work, cache: CacheId.Create(work.Id,work.Hash<#for(int j = 0; j< single; j++){#>
, inputSingle<#= j #>Result.Cache<#
}#><#
for(int j = 0; j< list; j++){
#>, inputList<#= j #>Result.Cache<#
}#>));
            });


            bool hasChanges = (await this.ForceUpdate(cache?.Id, cache?.Data, options).ConfigureAwait(false) )??false
<#for(int j = 0; j< single; j++){#>
            || inputSingle<#= j #>Result.HasChanges
<#}#>
<#for(int j = 0; j< list; j++){#>
            || inputList<#= j #>Result.HasChanges
<#}#>;

<#for(int j = 0; j< single; j++){#>
            if(inputSingle<#= j #>Result.HasChanges)
                this.Context.Logger.Info($"Found Changes for input with id: {inputSingle<#= j #>Result.Id}");
<#}#>
<#for(int j = 0; j< list; j++){#>
            if(inputList<#= j #>Result.HasChanges)
                this.Context.Logger.Info($"Found Changes for list with ids: {string.Join(", ", inputList<#= j #>Result.Ids)}");

<#}#>;
            var id = cache?.Id;
            if (hasChanges || (this.updateOnRefresh && options.Refresh) || cache is null || id is null)
            {
                // if we should refresh we need to update the repo or if the previous input was different
                // we need to perform the network operation to ensure we have no changes

                var result = await task;

                id = result.work.Id;
                hasChanges = !await this.CacheEquals(cache?.Data, result.cache.Data).ConfigureAwait(false);

                if(!hasChanges)
                    this.Context.Logger.Info($"Output will not have changes.");
                return this.Context.CreateStageResult(result.work, hasChanges, id, result.cache);

            }
            else {
                var actualTask = LazyTask.Create(async ()=>{
                    var temp = await task;
                    return temp.work;
                });
                return this.Context.CreateStageResult(actualTask, hasChanges, id, cache);
            }
        }

        protected virtual Task<bool?> ForceUpdate(string? id, string? hash, OptionToken options) => Task.FromResult<bool?>(null);

        protected Task<bool> CacheEquals([AllowNull]string item1, [AllowNull] string item2)
        {
            return Task.FromResult(Equals(item1, item2));
        }
    }
}
<# } #>


    //////////////// MULTI SIMPLE //////////////// 
<#{#>
namespace Multiple.Simple {
<#
    var cacheType = "CachelessIds";
    if(single+list>0)  
    {
        cacheType+="<";
        for (int j = 0; j < single; j++)
        {
            if(j>0)
            {
                cacheType +=", ";
            }
            cacheType+="TPreviousSingleCache"+ j ;
        }
        for (int j = 0; j < list; j++)
        {
            if(j+ single>0)
            {
                cacheType +=", ";
            }
            cacheType+="TPreviousListCache"+ j ;
        }
        cacheType+=">";
    }

             
#>

    public abstract class OutputMultiSimpleInputSingle<#= single #>List<#= list #>StageBase<
    <#for(int j = 0; j< single; j++){#>
 TInputSingle<#= j #>, TPreviousSingleCache<#= j #>,
    <#}#>
        <#for(int j = 0; j< list; j++){#>
 TInputList<#= j #>, TPreviousItemCache<#= j #>, TPreviousListCache<#= j #>,
    <#}#>
 TResult
 > : MultiStageBase<TResult, string,  <#=cacheType#>>

 
            <#for(int j = 0; j< single; j++){#>
 where TPreviousSingleCache<#= j #> : class
    <#}#>
        <#for(int j = 0; j< list; j++){#>
 where TPreviousListCache<#= j #> : class
 where TPreviousItemCache<#= j #> : class

    <#}#>

    {
    <#for(int j = 0; j< single; j++){#>
        private readonly StageBase<TInputSingle<#= j #>, TPreviousSingleCache<#= j #>> inputSingle<#= j #>;
    <#}#>
    <#for(int j = 0; j< list; j++){#>
        private readonly MultiStageBase<TInputList<#= j #>, TPreviousItemCache<#= j #>, TPreviousListCache<#= j #>> inputList<#= j #>;
    <#}#>
        private readonly bool updateOnRefresh;

        public OutputMultiSimpleInputSingle<#= single #>List<#= list #>StageBase(
    <#for(int j = 0; j< single; j++){#>
        StageBase<TInputSingle<#= j #>, TPreviousSingleCache<#= j #>> inputSingle<#= j #>,
    <#}#>
        <#for(int j = 0; j< list; j++){#>
        MultiStageBase<TInputList<#= j #>, TPreviousItemCache<#= j #>, TPreviousListCache<#= j #>> inputList<#= j #>,
    <#}#>
        IGeneratorContext context, string? name, bool updateOnRefresh = false) : base(context, name)
        {
    <#for(int j = 0; j< single; j++){#>
            this.inputSingle<#= j #> = inputSingle<#= j #>;
    <#}#>
    <#for(int j = 0; j< list; j++){#>
            this.inputList<#= j #> = inputList<#= j #>;
    <#}#>
            this.updateOnRefresh = updateOnRefresh;
        } 

        protected abstract Task<ImmutableList<IDocument<TResult>>> Work(
        
    <#for(int j = 0; j< single; j++){#>
        IDocument<TInputSingle<#= j #>> inputSingle<#= j#>, 
    <#}#>
    <#for(int j = 0; j< list; j++){#>
        ImmutableList<IDocument<TInputList<#= j #>>> inputList<#= j#>, 
    <#}#>
        OptionToken options);

        protected sealed override async Task<StageResultList<TResult, string, <#=cacheType#>>> DoInternal([AllowNull]  <#=cacheType#>? cache, OptionToken options)
        {
            if (options is null)
                throw new ArgumentNullException(nameof(options));


<#
                if(single +list >1){
#>
            await Task.WhenAll(
<#for(int j = 0; j< single; j++){#>
                this.inputSingle<#= j #>.DoIt(cache?.PreviousCache<#= j #>, options),
<#}#>
<#for(int j = 0; j< list; j++){#>
                this.inputList<#= j #>.DoIt(cache?.PreviousCache<#= j + single #>, options),
<#}#>
                Task.CompletedTask
            ).ConfigureAwait(false);
                <#}#>
<#for(int j = 0; j< single; j++){#>
            var inputSingle<#= j #>Result = await this.inputSingle<#= j #>.DoIt(cache?.PreviousCache<#= j #>, options).ConfigureAwait(false);
<#}#>
<#for(int j = 0; j< list; j++){

#>
            var inputList<#= j #>Result = await this.inputList<#= j #>.DoIt(cache?.PreviousCache<#= j + single #>, options).ConfigureAwait(false);
<#}#>
             
            var task = LazyTask.Create(async () =>
            {

            <#
                if(single +list >1){
#>
            await Task.WhenAll(
<#for(int j = 0; j< single; j++){#>
                inputSingle<#= j #>Result.Perform.AsTask(),
<#}#>
<#for(int j = 0; j< list; j++){#>
                inputList<#= j #>Result.Perform.AsTask(),
<#}#>
                Task.CompletedTask
            ).ConfigureAwait(false);
                <#}#>
<#for(int j = 0; j< single; j++){#>
            var inputSingle<#= j #>Performed = await inputSingle<#= j #>Result.Perform;
<#}#>
<#for(int j = 0; j< list; j++){#>
            var inputList<#= j #>Performed = await inputList<#= j #>Result.Perform;

            var inputList<#= j #>PerformedListTask = Task.WhenAll(inputList<#= j #>Performed.Select(async x => (await x.Perform)));
<#}#>

<#if(list>1){#>
await Task.WhenAll(
<#for(int j = 0; j< list; j++){#>
<#if(j>0){#>, <#}#>
             inputList<#= j #>PerformedListTask
<#}#>
).ConfigureAwait(false);
<#}#>

<#for(int j = 0; j< list; j++){#>
            var inputList<#= j #>PerformedList = await inputList<#= j #>PerformedListTask.ConfigureAwait(false);
<#}#>



                var oldChildCaches = cache?.Ids.ToImmutableDictionary(x => x.id, x => x.hash);

                var work = await this.Work(
                <#for(int j = 0; j< single; j++){#>
            inputSingle<#= j #>Performed,
<#}#>
<#for(int j = 0; j< list; j++){#>
            inputList<#= j #>PerformedList.ToImmutableList(),
<#}#>
 options).ConfigureAwait(false);
                             
                
                var list = work.Select(x=>
                {
                    var hasChanges =true;
                    if(oldChildCaches !=null && oldChildCaches.TryGetValue(x.Id, out var oldHash))
                        hasChanges = x.Hash != oldHash;
                    return (result: this.Context.CreateStageResult( x,hasChanges,x.Id, x.Hash), hash: x.Hash);
                
                }).ToArray();

<#
var parameter = new StringBuilder();
  for (int j = 0; j < single; j++)
  {
      parameter.Append(", inputSingle");
      parameter.Append(j);
      parameter.Append("Result.Cache");
  }
  for (int j = 0; j < list; j++)
  {
      parameter.Append(", inputList");
      parameter.Append(j);
      parameter.Append("Result.Cache");
  }
#>

                return (work: list.Select(x=>x.result).ToImmutableList(), cache: CachelessIds.Create(list.Select(x=>(x.result.Id, x.hash)).ToArray()<#=parameter#>));// { Data = work.cache.Item, Ids = ids }, work.cache.PreviousCache, childCaches.ToImmutable()));
            });


                            bool hasChanges = (await this.ForceUpdate(cache?.Ids, options).ConfigureAwait(false) ?? false)
<#for(int j = 0; j< single; j++){#>
            || inputSingle<#= j #>Result.HasChanges
<#}#>
<#for(int j = 0; j< list; j++){#>
            || inputList<#= j #>Result.HasChanges
<#}#>;

<#for(int j = 0; j< single; j++){#>
            if(inputSingle<#= j #>Result.HasChanges)
                this.Context.Logger.Info($"Found Changes for input with id: {inputSingle<#= j #>Result.Id}");
<#}#>
<#for(int j = 0; j< list; j++){#>
            if(inputList<#= j #>Result.HasChanges)
                this.Context.Logger.Info($"Found Changes for list with ids: {string.Join(", ", inputList<#= j #>Result.Ids)}");

<#}#>;

            var ids = cache?.Ids;
            if (hasChanges || (this.updateOnRefresh && options.Refresh) || cache is null)
            {
                // if we should refresh we need to update the repo or if the previous input was different
                // we need to perform the network operation to ensure we have no changes

                var result = await task;
                ids = await Task.WhenAll(result.work.Select(async x => ((await x.Perform).Id, (await x.Perform).Hash))).ConfigureAwait(false); // we want to make sure thate there are actually changes, so we compare the caches.
                hasChanges = !this.CacheEquals(cache?.Ids, result.cache.Ids);
                if(!hasChanges)
                    this.Context.Logger.Info($"Output will not have changes.");

                return this.Context.CreateStageResultList(result.work, hasChanges, ids.Select(x=>x.id).ToImmutableList(), result.cache);
            }
            else{
                var actualTask= LazyTask.Create(async ()=>{
                    var temp = await task;
                    return temp.work;
                });
                return this.Context.CreateStageResultList(actualTask, hasChanges, ids.Select(x=>x.id).ToImmutableList(), cache);
            }
        }

        protected virtual Task<bool?> ForceUpdate((string id, string hash)[]? ids, OptionToken options) => Task.FromResult<bool?>(null);


        private bool CacheEquals((string id, string hash)[]? item1, (string id, string hash)[]? item2)
        {
            if (item1 is null && item2 is null)
                return true;
            if (item1 is null || item2 is null)
                return false;

            return item1.SequenceEqual(item2);
        }

    
    }
}
<# } #>


//    //////////////// MULTI ADVANCED //////////////// 
//    <#{#>
//
//     public abstract class OutputMultiInputSingle<#= single #>List<#= list #>StageBase<
//    <#for(int j = 0; j< single; j++){#>
// TInputSingle<#= j #>, TPreviousSingleCache<#= j #>,
//    <#}#>
//        <#for(int j = 0; j< list; j++){#>
// TInputList<#= j #>, TPreviousItemCache<#= j #>, TPreviousListCache<#= j #>,
//    <#}#>
// TResult, TResultCache, TCache
// > : MultiStageBase<TResult, TResultCache, CacheIds<TCache>>
//        where TCache : class
//    {
//    <#for(int j = 0; j< single; j++){#>
//        private readonly StageBase<TInputSingle<#= j #>, TPreviousSingleCache<#= j #>> inputSingle<#= j #>;
//    <#}#>
//    <#for(int j = 0; j< list; j++){#>
//        private readonly StageBase<TInputList<#= j #>, TPreviousItemCache<#= j #>, TPreviousListCache<#= j #>> inputList<#= j #>;
//    <#}#>
//        private readonly bool updateOnRefresh;
//
//        public OutputMultiInputSingle<#= single #>List<#= list #>StageBase(
//    <#for(int j = 0; j< single; j++){#>
//        StageBase<TInputSingle<#= j #>, TPreviousSingleCache<#= j #>> inputSingle<#= j #>,
//    <#}#>
//        <#for(int j = 0; j< list; j++){#>
//        StageBase<TInputList<#= j #>, TPreviousItemCache<#= j #>, TPreviousListCache<#= j #>> inputList<#= j #>,
//    <#}#>
//        GeneratorContext context, bool updateOnRefresh = false) : base(context)
//        {
//    <#for(int j = 0; j< single; j++){#>
//            this.inputSingle<#= j #> = inputSingle<#= j #>;
//    <#}#>
//    <#for(int j = 0; j< list; j++){#>
//            this.inputList<#= j #> = inputList<#= j #>;
//    <#}#>
//            this.updateOnRefresh = updateOnRefresh;
//        } 
//
//        protected abstract Task<(ImmutableList<StageResult<TResult, TResultCache>> result, BaseCache<TCache> cache)> Work(
//        
//    <#for(int j = 0; j< single; j++){#>
//        StageResult<TInputSingle<#= j #>,TPreviousSingleCache<#= j #>> inputSingle<#= j#>, 
//    <#}#>
//    <#for(int j = 0; j< list; j++){#>
//        StageResultList<TInputList<#= j #>,TPreviousItemCache<#= j #>,TPreviousListCache<#= j #>> inputList<#= j#>, 
//    <#}#>
//       [AllowNull] TCache cache,
//        [AllowNull] ImmutableDictionary<string, BaseCache<TResultCache>>? childCaches,
//        OptionToken options);
//
//        protected sealed override async Task<StageResultList<TResult, TResultCache, CacheIds<TCache>>> DoInternal([AllowNull] CacheIds<TCache>? cache, OptionToken options)
//        {
//            if (cache != null && cache.PreviousCache.Length != <#= list + single #>)
//                throw new ArgumentException($"This cache should have exactly <#= list + single #> predecessor but had {cache.PreviousCache}");
//            if (options is null)
//                throw new ArgumentNullException(nameof(options));
//
//
//<#for(int j = 0; j< single; j++){#>
//            var inputSingle<#= j #>Result = await this.inputSingle<#= j #>(cache?.PreviousCache.Span[<#= j #>], options).ConfigureAwait(false);
//<#}#>
//<#for(int j = 0; j< list; j++){#>
//            var inputList<#= j #>Result = await this.inputList<#= j #>(cache?.PreviousCache.Span[<#= j + single #>], options).ConfigureAwait(false);
//<#}#>
//
//            var currentCache = cache?.Item;
//
//             
//            var task = LazyTask.Create(async () =>
//            {
//                var oldChildCaches = cache?.ChildCache.ToImmutableDictionary(x => x.Key, x => (BaseCache<TResultCache>)x.Value);
//
//                var work = await this.Work(
//                <#for(int j = 0; j< single; j++){#>
//            inputSingle<#= j #>Result,
//<#}#>
//<#for(int j = 0; j< list; j++){#>
//            inputList<#= j #>Result,
//<#}#>
//cache?.Item.Data, oldChildCaches, options).ConfigureAwait(false);
//                             
//                             var oldHashLookup = currentCache?.Ids.ToDictionary(x => x.id, x => x.hash) ?? new System.Collections.Generic.Dictionary<string, string>();
//                var ids = new (string id, string hash)[work.result.Count];
//                var childCaches = ImmutableDictionary<string, BaseCache>.Empty.ToBuilder();
//                for (int i = 0; i < ids.Length; i++)
//                {
//                    if (work.result[i].HasChanges)
//                    {
//                        var itemResult = await work.result[i].Perform;
//                        ids[i] = (itemResult.result.Id, itemResult.result.Hash);
//                        childCaches.Add(itemResult.result.Id, itemResult.cache);
//                    }
//                    else
//                    {
//                        if (cache is null || !cache.ChildCache.TryGetValue(work.result[i].Id, out var childCache))
//                            throw this.Context.Exception("The previous cache should exist if we had no changes.");
//                        childCaches.Add(work.result[i].Id, childCache);
//                        ids[i] = (work.result[i].Id, oldHashLookup[work.result[i].Id]);
//                    }
//                }
//
//                return (work.result, cache: BaseCache.Create(new CacheIds<TCache>() { Data = work.cache.Item, Ids = ids }, work.cache.PreviousCache, childCaches.ToImmutable()));
//            });
//
//
//            bool hasChanges = this.ForceUpdate(cache?.Item.Data, options) 
//<#for(int j = 0; j< single; j++){#>
//            || inputSingle<#= j #>Result.HasChanges
//<#}#>
//<#for(int j = 0; j< list; j++){#>
//            || inputList<#= j #>Result.HasChanges
//<#}#>;
//            System.Diagnostics.Debug.Assert(cache != null || hasChanges);
//
//            if (hasChanges || (this.updateOnRefresh && options.Refresh))
//            {
//                // if we should refresh we need to update the repo or if the previous input was different
//                // we need to perform the network operation to ensure we have no changes
//
//                var result = await task;
//                currentCache = result.cache.Item;
//                // we want to make sure thate there are actually changes, so we compare the caches.
//                hasChanges = !await this.CacheEquals(cache?.Item.Data, result.cache.Item.Data).ConfigureAwait(false);
//                // if we found that cache had no changes, maybe the childcaches where changed.
//                if (!hasChanges)
//                    hasChanges = !await this.ChildCacheEquals(cache?.ChildCache.ToImmutableDictionary(x => x.Key, x => ((BaseCache<TResultCache>)x.Value).Item), result.cache.ChildCache.ToImmutableDictionary(x => x.Key, x => ((BaseCache<TResultCache>)x.Value).Item)).ConfigureAwait(false);
//           }
//
//            // if currentCache is null, hasChanges must be true and so currentCache will be set.
//            var theId = currentCache!.Ids;
//
//            return this.Context.CreateStageResult(task, hasChanges, theId.Select(x => x.id).ToImmutableList());
//        }
//
//        protected virtual bool ForceUpdate([AllowNull]TCache cache, OptionToken options) => true;
//
//
//        protected virtual Task<bool> CacheEquals([AllowNull]TCache item1, [AllowNull]TCache item2)
//        {
//            return Task.FromResult(Equals(item1, item2));
//        }
//
//        protected virtual async Task<bool> ChildCacheEquals([AllowNull]ImmutableDictionary<string, TResultCache> item1, [AllowNull]ImmutableDictionary<string, TResultCache> item2)
//        {
//            if (item1 is null && item2 is null)
//                return true;
//
//            if (item1 is null || item2 is null)
//                return false;
//
//            if (item1.Count != item2.Count)
//                return false;
//
//            var itemResults = await Task.WhenAll(item1.Select(async pair => item2.TryGetValue(pair.Key, out var entry) && await this.ChildCacheElementRquals(pair.Value, entry).ConfigureAwait(false))).ConfigureAwait(false);
//            return itemResults.All(x => x);
//        }
//
//        protected virtual Task<bool> ChildCacheElementRquals([AllowNull] TResultCache item1, [AllowNull] TResultCache item2)
//        {
//            return Task.FromResult(Equals(item1, item2));
//        }
//    }
//
//
//<# } #>
//
//

<# } #>



    #pragma warning disable CS8618 // Non-nullable field is uninitialized. Consider declaring as nullable.
#pragma warning disable CA1819 // Properties should not return arrays


<#
for(int total = 0; total<=maxSingleParameter+maxListParameter;total++)
{

#>

public static partial class CacheId{

    public static CacheId<TCache<#
    for (int i = 0; i < total; i++)
    {#>, TPreview<#=i#><#             }
    #>> Create<TCache<#
    for (int i = 0; i < total; i++)
    {#>, TPreview<#=i#><#             }
    #>>(string id, TCache cache<#
    for (int i = 0; i < total; i++)
    {#>, TPreview<#=i#> preview<#=i#><#             }
    #>) 
        where TCache : class
<#
    for (int i = 0; i < total; i++)
    {#>
        where TPreview<#=i#> : class
<#             }
    #>
 => new CacheId<TCache<#
    for (int i = 0; i < total; i++)
    {#>, TPreview<#=i#><#             }
    #>>(){ Id = id, Data = cache<#
    for (int i = 0; i < total; i++)
    {#>, PreviousCache<#=i#> = preview<#=i#><#             }
    #>};
}

public static  partial class CacheIds{

    public static CacheIds<TCache<#
    for (int i = 0; i < total; i++)
    {#>, TPreview<#=i#><#             }
    #>> Create<TCache<#
    for (int i = 0; i < total; i++)
    {#>, TPreview<#=i#><#             }
    #>>((string id, string hash)[] ids, TCache cache<#
    for (int i = 0; i < total; i++)
    {#>, TPreview<#=i#> preview<#=i#><#             }
    #>) 
        where TCache : class
<#
    for (int i = 0; i < total; i++)
    {#>
        where TPreview<#=i#> : class
<#             }
    #>
 => new CacheIds<TCache<#
    for (int i = 0; i < total; i++)
    {#>, TPreview<#=i#><#             }
    #>>(){ Ids = ids, Data = cache<#
    for (int i = 0; i < total; i++)
    {#>, PreviousCache<#=i#> = preview<#=i#><#             }
    #>};
}



    public class CacheId<TCache<#
    for (int i = 0; i < total; i++)
    {#>, TPreview<#=i#><#             }
    #>>
        where TCache : class
<#
    for (int i = 0; i < total; i++)
    {#>
        where TPreview<#=i#> : class
<#             }
    #>
    {

<#
    for (int i = 0; i < total; i++)
    {#>
        public TPreview<#=i#>? PreviousCache<#=i#> {get;set;}
<#             }
    #>

        public TCache? Data { get; set; }

        public string Id { get; set; }
    }

        public class CacheIds<TCache<#
    for (int i = 0; i < total; i++)
    {#>, TPreview<#=i#><#             }
    #>>
        where TCache : class
<#
    for (int i = 0; i < total; i++)
    {#>
        where TPreview<#=i#> : class
<#             }
    #>
    {
    <#
    for (int i = 0; i < total; i++)
    {#>
        public TPreview<#=i#>? PreviousCache<#=i#> {get;set;}
<#             }
    #>

        public TCache? Data { get; set; }

        public (string id, string hash)[] Ids { get; set; }
    }


public  partial class CachelessId{

    public static CachelessId<#
    if(total>0){
    #><<#
    for (int i = 0; i < total; i++)
    {#><#if(i>0){#> ,<#}#> TPreview<#=i#><#             }
    #>><#}#> Create<#
    if(total>0){
    #><<#
    for (int i = 0; i < total; i++)
    {#><#if(i>0){#> ,<#}#> TPreview<#=i#><#             }
    #>><#}#>(string id<#
    for (int i = 0; i < total; i++)
    {#>, TPreview<#=i#> preview<#=i#><#             }
    #>) 
<#
    for (int i = 0; i < total; i++)
    {#>
        where TPreview<#=i#> : class
<#             }
    #>
 => new CachelessId<#
    if(total>0){
    #><<#
    for (int i = 0; i < total; i++)
    {#><#if(i>0){#> ,<#}#> TPreview<#=i#><#             }
    #>><#}#>(){ Id = id<#
    for (int i = 0; i < total; i++)
    {#>, PreviousCache<#=i#> = preview<#=i#><#             }
    #>};
}

public   partial class CachelessIds{

    public static CachelessIds<#
    if(total>0){
    #><<#
    for (int i = 0; i < total; i++)
    {#><#if(i>0){#> ,<#}#> TPreview<#=i#><#             }
    #>><#}#> Create<#
    if(total>0){
    #><<#
    for (int i = 0; i < total; i++)
    {#><#if(i>0){#> ,<#}#> TPreview<#=i#><#             }
    #>><#}#>((string id, string hash)[] ids<#
    for (int i = 0; i < total; i++)
    {#>, TPreview<#=i#> preview<#=i#><#             }
    #>) 
<#
    for (int i = 0; i < total; i++)
    {#>
        where TPreview<#=i#> : class
<#             }
    #>
 => new CachelessIds<#
    if(total>0){
    #><<#
    for (int i = 0; i < total; i++)
    {#><#if(i>0){#> ,<#}#> TPreview<#=i#><#             }
    #>><#}#>(){ Ids = ids<#
    for (int i = 0; i < total; i++)
    {#>, PreviousCache<#=i#> = preview<#=i#><#             }
    #>};
}



    public partial class CachelessId<#
    if(total>0){
    #><<#
    for (int i = 0; i < total; i++)
    {#><#if(i>0){#> ,<#}#> TPreview<#=i#><#             }
    #>><#}#>
<#
    for (int i = 0; i < total; i++)
    {#>
        where TPreview<#=i#> : class
<#             }
    #>
    {

<#
    for (int i = 0; i < total; i++)
    {#>
        public TPreview<#=i#>? PreviousCache<#=i#> {get;set;}
<#             }
    #>


        public string Id { get; set; }
    }

        public partial class CachelessIds<#
    if(total>0){
    #><<#
    for (int i = 0; i < total; i++)
    {#><#if(i>0){#> ,<#}#> TPreview<#=i#><#             }
    #>><#}#>
<#
    for (int i = 0; i < total; i++)
    {#>
        where TPreview<#=i#> : class
<#             }
    #>
    {
    <#
    for (int i = 0; i < total; i++)
    {#>
        public TPreview<#=i#>? PreviousCache<#=i#> {get;set;}
<#             }
    #>


        public (string id, string hash)[] Ids { get; set; }
    }


  

<# } #>

#pragma warning restore CA1819 // Properties should not return arrays
#pragma warning restore CS8618 // Non-nullable field is uninitialized. Consider declaring as nullable.

}