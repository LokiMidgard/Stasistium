<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".tt.cs" #>

using Stasistium.Documents;
using System.Collections.Immutable; 
using System.Threading.Tasks;
using Stasistium.Stages;
using System;
using Stasistium.Core;
using System.Diagnostics.CodeAnalysis;
using System.Collections.Generic;
using System.Linq;

namespace Stasistium.Stages
{

<#


int numberOfElements = 4;

for (int i = 1; i <= numberOfElements; i++)
{
    string classGenerics = string.Join(", ", Enumerable.Range(1,i).Select(x=> "TCache"+x) );
    string baseGenerics = string.Join(", ", Enumerable.Range(1,i).Select(x=> "T, TCache"+x) );
    string whereStatements = string.Join("\n        ", Enumerable.Range(1,i).Select(x=> "where TCache"+x+" : class") );

    string constructorArguments = string.Join(", ", Enumerable.Range(1,i).Select(x=> "StageBase<T, TCache"+x+"> input"+x) );
    string baseArguments = string.Join(", ", Enumerable.Range(1,i).Select(x=> "input"+x) );
    
    string overideArguments =string.Join(", ", Enumerable.Range(1,i).Select(x=> "IDocument<T> input"+x) );
    string toListArguments =string.Join(", ", Enumerable.Range(1,i).Select(x=> "input"+x) );

#>

    public class ConcatStage<T, <#=classGenerics#>> : GeneratedHelper.Multiple.Simple.OutputMultiSimpleInputSingle<#=i#>List0StageBase<<#=baseGenerics#>, T>
        <#=whereStatements#>
    {
        public ConcatStage(<#=constructorArguments#>, IGeneratorContext context, string? name) : base(<#=baseArguments #>, context, name)
        {
        }

        protected override Task<ImmutableList<IDocument<T>>> Work(<#=overideArguments#>, OptionToken options)
        {
            return Task.FromResult(ImmutableList.Create(<#=toListArguments#>));
        }
    }


<#
             }

#>

<#



for (int i = 1; i <= numberOfElements; i++)
{
    string classGenerics = string.Join(", ", Enumerable.Range(1,i).Select(x=> "TItemCache"+x+", TCache"+x) );
    string baseGenerics = string.Join(", ", Enumerable.Range(1,i).Select(x=> "TCache"+x) );
    string whereStatements = string.Join("\n        ", Enumerable.Range(1,i).Select(x=> "where TItemCache"+x+" : class\n        where TCache"+x+" : class") );

    string constructorArguments = string.Join(", ", Enumerable.Range(1,i).Select(x=> "MultiStageBase<T, TItemCache"+x+", TCache"+x+"> input"+x) );
    
    string overideArguments =string.Join(", ", Enumerable.Range(1,i).Select(x=> "ImmutableList<IDocument<T>> input"+x) );
    string toListArguments =string.Join(", ", Enumerable.Range(1,i).Select(x=> "input"+x) );

#>

    public class ConcatManyStage<T, <#=classGenerics#>> : MultiStageBase<T, string, ConcatStageManyCache<<#=baseGenerics#>>>
        <#=whereStatements#>
    {

<#
for (int j = 1; j <= i; j++)
{
#>
        private readonly MultiStageBase<T, TItemCache<#= j #>, TCache<#= j #>> input<#= j #>;
<#
}
#>
        public ConcatManyStage(<#=constructorArguments#>, IGeneratorContext context, string? name = null) : base(context, name)
        {
<#
for (int j = 1; j <= i; j++)
{
#>
            this.input<#= j #> = input<#= j #>;
<#
}
#>
        }

        protected override async Task<StageResultList<T, string, ConcatStageManyCache<<#=baseGenerics#>>>> DoInternal([AllowNull] ConcatStageManyCache<<#=baseGenerics#>>? cache, OptionToken options)
        {
<#
for (int j = 1; j <= i; j++)
{
var postFix= j>1 ? j.ToString() : string.Empty;
#>
            var resultTask<#= j #> = this.input<#= j #>.DoIt(cache?.PreviousCache<#= postFix #>, options);
<#
}
#>
await Task.WhenAll(
<#
for (int j = 1; j <= i; j++)
{
#>
             <#if(j>1){#>,<#}#>resultTask<#= j #>
<#
}
#>
).ConfigureAwait(false);
<#
for (int j = 1; j <= i; j++)
{
#>
            var result<#= j #> = await resultTask<#= j #>.ConfigureAwait(false);
<#
}
#>
            var task = LazyTask.Create(async () =>
            {
                var list = ImmutableList<StageResult<T, string>>.Empty.ToBuilder();
                var newCache = new ConcatStageManyCache<<#=baseGenerics#>>();

                var hashList = new List<string>();
<#
for (int j = 1; j <= i; j++)
{
var postFix= j>1 ? j.ToString() : string.Empty;
#>

                if (result<#= j #>.HasChanges)
                {
                    var performed = await result<#= j #>.Perform;
                    newCache.Ids<#= postFix #> = new string[performed.Count];
                    newCache.PreviousCache<#= postFix #> = result<#= j #>.Cache;


                    for (int i = 0; i < performed.Count; i++)
                    {
                        var child = performed[i];

                        if (child.HasChanges)
                        {
                            var childPerformed = await child.Perform;

                            
                            if (cache == null || !cache.IdToHash.TryGetValue(childPerformed.Id, out string? oldHash))
                                oldHash = null;
                            var childHashChanges = oldHash != childPerformed.Hash;

                            list.Add(StageResult.CreateStageResult(this.Context, childPerformed, childHashChanges, childPerformed.Id, childPerformed.Hash, childPerformed.Hash));
                            newCache.IdToHash.Add(child.Id, childPerformed.Id);

                        }
                        else
                        {

                            var childTask = LazyTask.Create(async () =>
                            {
                                var childPerform = await child.Perform;
                                return childPerform;
                            });
                            if (cache is null || !cache.IdToHash.TryGetValue(child.Id, out var oldHash))
                                throw this.Context.Exception("Should Not Happen");
                            list.Add(StageResult.CreateStageResult(this.Context, childTask, false, child.Id, oldHash, oldHash));
                            newCache.IdToHash.Add(child.Id, oldHash);

                        }
                        newCache.Ids<#= postFix #>[i] = child.Id;
                        hashList.Add(child.Hash);
                    }

                }
                else
                {
                    if (cache is null)
                        throw this.Context.Exception("Should Not Happen");
                    for (int i = 0; i < cache.Ids<#= postFix #>.Length; i++)
                    {
                        var currentIndex = i;
                        var childTask = LazyTask.Create(async () =>
                        {
                            var performed = await result<#= j #>.Perform;
                            var chiledIndex = performed[currentIndex];
                            var childPerform = await chiledIndex.Perform;
                            // We are in the no changes part. So ther must be no changes.
                            System.Diagnostics.Debug.Assert(!chiledIndex.HasChanges);

                            return childPerform;
                        });
                        if (cache is null || !cache.IdToHash.TryGetValue(cache.Ids<#= postFix #>[currentIndex], out var oldHash))
                            throw this.Context.Exception("Should Not Happen");

                        list.Add(StageResult.CreateStageResult(this.Context, childTask, false, cache.Ids<#= postFix #>[currentIndex], oldHash, oldHash));
                        hashList.Add(oldHash);

                    }
                    newCache.PreviousCache<#= postFix #> = cache.PreviousCache<#= postFix #>;
                    newCache.Ids<#= postFix #> = cache.Ids<#= postFix #>;
                    foreach (var id in newCache.Ids<#= postFix #>)
                    {
                        if (!cache.IdToHash.TryGetValue(id, out var oldHash))
                            throw this.Context.Exception("Should Not Happen");
                        newCache.IdToHash.Add(id, oldHash);
                    }
                }

<#
}
#>
                newCache.Hash = this.Context.GetHashForObject(hashList);

                return (result:list.ToImmutable(),cache: newCache);
            });

            var hasChanges = false
<#
for (int j = 1; j <= i; j++)
{
#>
                ||result<#= j #>.HasChanges
<#
}
#>                ;
            var ids = ImmutableList<string>.Empty.ToBuilder();

            if (hasChanges || cache is null)
            {
                var performed = await task;
                hasChanges = performed.result.Any(x => x.HasChanges);
<#
for (int j = 1; j <= i; j++)
{
var postFix= j>1 ? j.ToString() : string.Empty;
#>                if (!hasChanges && cache != null)
                    hasChanges = !performed.cache.Ids<#= postFix #>.SequenceEqual(cache.Ids<#= postFix #>);
<#
}
#>
<#
for (int j = 1; j <= i; j++)
{
var postFix= j>1 ? j.ToString() : string.Empty;
#>
                ids.AddRange(performed.cache.Ids<#= postFix #>);
<#
}
#>
                return this.Context.CreateStageResultList(performed.result, hasChanges, ids.ToImmutable(), performed.cache, performed.cache.Hash
<#
for (int j = 1; j <= i; j++)
{
#>

                ,result<#= j #>.Cache
<#
}
#>
                );
            }
            else
            {
<#
for (int j = 1; j <= i; j++)
{
var postFix= j>1 ? j.ToString() : string.Empty;
#>
                ids.AddRange(cache.Ids<#= postFix #>);
<#
}
#>
                var actualTask = LazyTask.Create(async ()=>{
                    var temp = await task;
                return temp.result;
            });
            return this.Context.CreateStageResultList(actualTask, hasChanges, ids.ToImmutable(), cache, cache.Hash

<#
for (int j = 1; j <= i; j++)
{
var postFix= j>1 ? j.ToString() : string.Empty;
#>
                ,result<#= j #>.Cache
<#
}
#>            
            
            );
            }
        }
    }
#pragma warning disable CS8618 // Non-nullable field is uninitialized. Consider declaring as nullable.
#pragma warning disable CA1819 // Properties should not return arrays
#pragma warning disable CA2227 // Collection properties should be read only

    public class ConcatStageManyCache<<#=baseGenerics#>> : IHavePreviousCache<
<#
for (int j = 1; j <= i; j++)
{
#>
<#
if(j>1)
{
#>,
<#
}
#>

    TCache<#= j #>
<#
}
#>
    >
    <#
for (int j = 1; j <= i; j++)
{
#>
    where TCache<#= j #> : class
<#
}
#>
    {


<#
for (int j = 1; j <= i; j++)
{
var postFix= j>1 ? j.ToString() : string.Empty;
#>
        public string[] Ids<#= postFix #> { get; set; }
        public TCache<#= j #> PreviousCache<#= postFix #> { get; set; }

<#
}
#>

        public string Hash {get; set;}
        public Dictionary<string, string> IdToHash { get; set; }

        public ConcatStageManyCache()
        {
            this.IdToHash = new Dictionary<string, string>();
        }
    }
#pragma warning restore CA2227 // Collection properties should be read only
#pragma warning restore CS8618 // Non-nullable field is uninitialized. Consider declaring as nullable.
#pragma warning restore CA1819 // Properties should not return arrays
<#
             }

#>


}

namespace Stasistium
{


    public static partial class StageExtensions
    {
<#
for (int i = 1; i <= numberOfElements; i++)
{
    string classGenerics = string.Join(", ", Enumerable.Range(1,i).Select(x=> "TCache"+x) );
    string argumentList = string.Join(", ", Enumerable.Range(1,i).Select(x=> "StageBase<T, TCache"+x+"> input"+x) );
    string argumentList2 = string.Join(", ", Enumerable.Range(1,i).Select(x=> "input"+x) );
    string generics = string.Join(", ", Enumerable.Range(1,i).Select(x=> "TCache"+x) );
    
    string whereStatements = string.Join("\n            ", Enumerable.Range(1,i).Select(x=> "where TCache"+x+" : class") );
    string notNull = string.Join("\n            ", Enumerable.Range(1,i).Select(x=> "if(input"+x+" is null)\n                 throw new ArgumentNullException(nameof(input"+x+"));") );

#>
        public static ConcatStage<T, <#=classGenerics#>> Concat<T, <#=generics #>>(this <#=argumentList#>, string? name = null)
            <#=whereStatements#>
        {
            <#=notNull#>
            return new ConcatStage<T, <#=classGenerics#>>(<#=argumentList2 #>, input1.Context, name);
        }
<#
             }

#>

<#
for (int i = 1; i <= numberOfElements; i++)
{
    string classGenerics = string.Join(", ", Enumerable.Range(1,i).Select(x=> "TItemCache"+x+", TCache"+x) );
    string argumentList = string.Join(", ", Enumerable.Range(1,i).Select(x=> "MultiStageBase<T, TItemCache"+x+", TCache"+x+"> input"+x) );
    string argumentList2 = string.Join(", ", Enumerable.Range(1,i).Select(x=> "input"+x) );
    string generics = string.Join(", ", Enumerable.Range(1,i).Select(x=> "TItemCache"+x+", TCache"+x) );
    
    string whereStatements = string.Join("\n            ", Enumerable.Range(1,i).Select(x=> "where TItemCache"+x+" : class\n        where TCache"+x+" : class") );
    string notNull = string.Join("\n            ", Enumerable.Range(1,i).Select(x=> "if(input"+x+" is null)\n                 throw new ArgumentNullException(nameof(input"+x+"));") );

#>
        public static ConcatManyStage<T, <#=classGenerics#>> Concat<T, <#=generics #>>(this <#=argumentList#>, string? name = null)
            <#=whereStatements#>
        {
            <#=notNull#>
            return new ConcatManyStage<T, <#=classGenerics#>>(<#=argumentList2 #>, input1.Context, name);
        }
<#
             }

#>
    }
}























